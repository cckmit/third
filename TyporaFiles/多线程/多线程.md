## 创建线程的方法

Thread、Runnable、Callable Future FutureTask



```java
package com.beitie.thread;

import java.util.concurrent.Callable;

/**
 * @author betieforever
 * @description 描述
 * @date 2021/8/31
 */
public class CallableThread implements Callable<String>{
    public static void main(String[] args) {
    }
    private int id;

    public CallableThread(int id) {
        this.id = id;
    }

    @Override
    public String call() throws Exception {
        return "中国人-------"+id;
    }
}



```

```java
public class CallableTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService service= Executors.newCachedThreadPool();
        ArrayList<Future<String>> list=new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            list.add(service.submit(new CallableThread(i)));
        }
        for (Future<String> fs : list) {
            if(fs.isDone()){
                System.out.println(fs.get());
            }else{
                System.out.println("Future result is not yet complete");
            }
        }
        service.shutdown();
    }
}
```

结果显示

~~~
中国人-------0
中国人-------1
中国人-------2
中国人-------3
中国人-------4
中国人-------5
中国人-------6
Future result is not yet complete
中国人-------8
Future result is not yet complete

Process finished with exit code 0

~~~

## 线程状态

**已创建状态 已就绪状态（可运行状态）  运行状态阻塞状态  死亡状态**

## sleep、wait、notify、notifyAll

sleep时线程进入阻塞状态，其他访问该对象的线程一律不可运行，因为对象锁没有释放，待睡眠结束，线程重新进入可运行状态

wait 等待状态，当前线程阻塞，释放对象锁，其他线程可以访问该对象，待notify、notifyAll后线程重新进入可运行状态