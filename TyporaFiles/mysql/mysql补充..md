**索引使用原因**

​		执行时间长，等待时间长

**索引的建立**

**索引使用**

## 索引的不失效	

1、数据量小的表不要建立索引，因为建立用处不大，还会增加额外的开销

2、不经常使用的列不要建立索引，因为不常用，建立索引的用处也不大

3、经常频繁更新的列不要建立索引，因为肯定会影响插入或者修改的效率

4、尽量避免在where子句中使用！=或者<> ,这样会导致索引失效

5、不要使用like是以"%param"这样，也会导致索引失效

6、尽量避免使用null值，因为含有空值的列很难优化，使得索引、索引的统计信息以及比较运算更加复杂，可以采用0、一个特殊的值或者一个空字符串

7、select 不要使用*，

8、避免使用null值判断

9、合理的分页技术 

~~~yml
#使用
select id,name from product where id&gt; 866612 limit 20；
#而不是
select id,name from product limit 866613, 20
~~~



![img](mysql补充./1110857-20200318144325672-94115235.png)

mysql的架构可以分为server层和存储引擎层两个部分。

server层包括连接器、查询缓存、分析器、优化器、执行器等模块

存储引擎负责数据的存储和提取。

第一步连接器：通过账号和密码连接到对应的数据库上，连接器负责与客户端建立连接，获取权限，维持和管理连接。连接分为长连接和短连接，长连接是指连接成功后，客户端不断有请求，则一直使用同一个连接。短连接：处理几个请求后，断开连接，之后的请求需要重新连接。

第二步查询缓存：建立连接之后，mysql拿到一个查询请求后，会先查询缓存中之前是否执行过这条语句，如果查询缓存命中，则查询结果直接返回给客户端，如果查询缓存不命中，就会继续后面的执行阶段。完成以后，执行结果会被存入查询缓存中。大多数情况下不建议使用查询缓存。如果缓存命中，mysql不需要执行后面的复杂操作，就可以直接返回结果，效率很高，但是查询缓存失效非常频繁，只要有对一个表的更新，这个表的所有查询缓存都会被清空，因此可能你费力地把结果缓存起来，还没使用，就被一个更新全部清空了。除非你的业务是一张静态表，很长时间才会更新一次，这种情况下可以使用查询缓存。

第三步分析器：mysql在执行之前，首先会对sql语句做词法解析和语法解析，以确定你要做什么，并会识别语句中的关键词，比如select，order by等，以及解析sql语法是否正确等。

第四步优化器：优化器是数据库的一个核心子系统，你也可以把他理解为 MySQL 数据库中的一个核心模块或者一个核心功能模块。优化器的目的是按照一定原则来得到它认为的目标SQL在当前情形下最有效的执行路径,优化器的目的是为了得到目标SQL的执行计划。经过分析器，mysql就知道你要做什么了。SQL 在执行的过程中经过优化器，并由优化器生成 SQL 的执行计划。

传统优化器分为CBO和RBO两种

- RBO--- Rule_Based Potimizer 基于规则的优化器:RBO所用的判断规则是一组内置的规则，这些规则是硬编码在数据库的编码中的，RBO会根据这些规则去从SQL诸多的路径中来选择一条作为执行计划（比如在RBO里面，有这么一条规则：有索引使用索引。那么所有带有索引的表在任何情况下都会走索引）所以，RBO现在被很多数据库抛弃（oracle默认是CBO，但是仍然保留RBO代码，MySQL只有CBO），RBO最大问题在于硬编码在数据库里面的一系列固定规则，来决定执行计划。并没有考虑目标SQL中所涉及的对象的实际数量，实际数据的分布情况，这样一旦规则不适用于该SQL，那么很可能选出来的执行计划就不是最优执行计划了。
- CBO---Cost_Based Potimizer 基于成本的优化器:CBO在会从目标诸多的执行路径中选择一个成本最小的执行路径来作为执行计划。这里的成本他实际代表了MySQL根据相关统计信息计算出来目标SQL对应的步骤的IO，CPU等消耗。也就是意味着数据库里的成本实际上就是对于执行目标SQL所需要IO,CPU等资源的一个估计值。而成本值是根据索引，表，行的统计信息计算出来的(计算过程比较复杂)。

第五步执行器：开始执行的时候，首先会判断此次连接是否有对应的操作权限，如果没有，则返回没有权限的错误。如果有权限，则打开表继续执行。打开表的时候，执行器会根据表的引擎定义，去使用这个引擎提供的接口。

## 分析索引的使用效果

explain select * from users;

事务的隔离级别

1. 读未提交（READ UNCOMMITTED）
2. 读提交 （READ COMMITTED）
3. 可重复读 （REPEATABLE READ）
4. 串行化 （SERIALIZABLE）

从上到下隔离级别依次提高

**其中可重复读的实现原理：**

表中每行记录多了两列：数据创建时间的事务版本号DB_TRX_ID和数据删除时的事务版本号DB_ROLL_PT

1、插入时：记录中DB_TRX_ID插入当前的事务版本号 DB_ROLL_PT不做任何记录

2、修改时：会复制一份记录并标记DB_ROLL_PT为当前事务的版本号，在原纪录上面会标记DB_TRX_ID为当前事务的版本号

3、删除时：会标记记录的DB_ROLL_PT为当前事务的版本号

4、查询时：查询DB_TRX_ID小于当前事务版本号的，这样就不会查询到后面事务插入的数据；查询DB_ROLL_PT大于等于当前事务版本好的，这样就不会查询到事务开始之前的版本。

